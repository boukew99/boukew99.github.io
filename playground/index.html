<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<style>
	 h1{
		  font-size: 1.8em;
		  margin-top: 0;
		  color: royalblue;
		} h2 {
		  font-size: 1.5em;
		  color: darkgreen;
		} h3 {
			color:darkred;
		} body {
		  font-family: Tahoma, sans-serif;
		  background-color: #ed9;
		}header, main, footer {
		  margin: 0 auto;
		  max-width: 55em; 
			border-bottom:4px solid;
		}main {
		  background-color: beige;
		  padding: .2em 1.2em .5em 1.1em;
		  line-height: 1.5;
		  text-align:left;
		  margin-bottom:1em;
		}
		footer {
			background-color: orange;
			padding: 1em;
		}
	</style>
	<title>Parser - boukew99</title>	
	<link rel="icon" type="image/x-icon" href="favicon.ico">
</head><body><main>
<header>
<h1>Playground</h1>
<canvas></canvas>

<script>
//game(1, stdProgress^2 - y^2, 1)


function* game(players, track, gameSpeed) {
	const speed = 10 * gameSpeed
	const boundarySlowdownMultiplier = ln(stdSidestep)
	
	const vehicles = [].concat(createVehicles(players)).concat(createNPC(16-players))
	
	while (true) {
		Let stdSidestep = stick.x + arrows.x + touch.x
		let stdBreak = axis + down + touch.y
		let throw = button + up + tap
		let input = yield {}
	}


function createVehicles(amount){
	const palette = [#f00, #0f0, #00f]
	return [].size(4).map((index)=> {
		"progress":0,
		"offset":0,
		"color": palette[index],
		"throwable":"",
	}
	
	speed, track, boundary, stdBreak, stdSideStep, throw


// frame 
// spritesheets for animation

// windows example: {"run":[0, 4], "jump":[4,5]}
function* switchFrame(windows) {
	
	let window = yield frame
	if (window) {
		jump
	}
}

// Combinator by boukew99

// Unique Number Generator 
function* UniqueNumberGenerator(start, offset, range, normalize){
  let current = start
  let next = offset
  
  while(true) {
    yield (normalize ? current % range / range : current % range); 
    [current, next] = [next, next + current];
  }
}
/*
//https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#advanced_generators
function* fibonacci(start, offset){
  let current = start
  let next = offset
  while(true) {
    yield current; 
    [current, next] = [next, next + current];
  }
}

export function* getUniqueIntegerGenerator(minimum, offset, range) {  
	const fib = fibonacci(minimum, offset)
	while(true){
 		yield fib.next().value % range
  }
}
export function* getUniqueNormalizedGenerator(minimum, offset, range) {  
	const ung = getUniqueIntegerGenerator(minimum, offset, range)
	while(true){
 		yield ung.next().value / range
  }
}

/*Iterations
export function setSeed(minimum, offset){
	fibonacciCache[0] = offset
	fibonacciCache[1] = minimum
	sequence = fibonacciGenerator(minimum,offset)
}
let fibonacciCache = [0,1]
function fibonacci(){
	const newUniqueNumber = fibonacciCache[0] + fibonacciCache[1]
	fibonacciCache[0] = fibonacciCache[1]
	fibonacciCache[1] = newUniqueNumber
	return newUniqueNumber
}
function* fibonacciGenerator(start, offset){
  let current = start
  let next = offset
  while(true) {
    const shift = yield current; //shift next?
    [current, next] = [next, next + current];
  }
}
const sequence = fibonacciGenerator(0,1);
export function getRandomInteger(range){
	return fibonacci() % range
}
export function getRandomNormalized(range){
	return getRandomInteger(range) / range
}
function* getUniqueIntegerGeneratorIntegrated(start, offset, range) {  
	let current = start
  let next = offset
  while(true) {
    const shift = yield (current % range); //shift next?
    [current, next] = [next, next + current];
  } 
}
*/

// local score tracking
// highscore = {}
// scores = [{}]
// highscore = int

function addHighscore(name, score) {
	const threshold = safeStorage("highscore", 0)
	let scores = safeStorage("scores", [])
	scores.push({"name":name,"score":score, "time":new Date().getHours()})
	
	if (score > threshold) {
		let records = safeStorage("records", {})
		records.set(name, score)
		localStorage.setItem("records", records)
		localStorage.setItem("highscore", score)
	}
}

function safeStorage(key, default){
	if (localStorage.getItem(key) == null) {
		return default
	}
	else {
		return localStorage.getItem(key)
}

function getRecords(limit) {
	const records = localStorage.getItem("records")
	scores.filter(score => score.score > limit)
	
	// Multi-dimensional physics by boukew99

// physic shape
function shape(diameter, rounding = 1, aspect = 1) {

}
//       -difference------->
//       -direction->
// -point|------------------|collider
let pointIntersection = (point, direction, collider) => z{
	const difference = collider - point
	if (sign(direction) == sign(difference))
		return false
	else {
		return point + direction > difference
		
	//return point + direction * sign(difference) > difference
}
function intersection(shape, direction, collider) {
	return 
}

let crossable = (difference, delta) => (difference * delta) > 0 //same direction

let circleIntersection = (radius, delta, difference, backRadius) => {
	radius + delta > difference - backRadius
} 
let contactCheck = (point, radius, delta backpoint, backradius) => {
	const difference = backpoint - point
	if crossable(difference, delta) {
		circleIntersection(radius, delta, difference, backRadius)
	} 
	else false	
}

let circleTrack = (x, y) => {
	{"x":cos(x), "y":sin(y)}
}
let pathMove = (curve) => {
	let delta = yield curve(
	return length * offset
}
</script>                                                               

</body></html>