<!DOCTYPE html>
<html lang="en">
<head><meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1"> 
	<meta name="author" content="boukew99">
	<meta name="description" content="tiny website for testing web interaction on different devices">
	<link rel="stylesheet" href="../boukew99.css">
	<link rel="icon" type="image/x-icon" href="hand-smile.ico">
	<meta property="og:image" content="index/computer-wizard-media.png"/>
	<title>Frictionless Interaction</title>
	<style>
		.inverse {
			filter: invert();
		}
		kbd {
		    background-color: #eee;
		    border-radius: 3px;
		    border: 1px solid #b4b4b4;
		    box-shadow: 0 1px 1px rgba(0, 0, 0, .2), 0 2px 0 0 rgba(255, 255, 255, .7) inset;
		    color: #333;
		    display: inline-block;
		    font-size: 1.5em;
		    font-weight: 700;
		    line-height: 1;
		    padding: 2px 4px;
		    white-space: nowrap;
		   }
		</style>
</head>	
<body><header><h1>Interaction without friction</h1>
<p>The ultimate for interaction is frictionless, but once there it becomes invisible.</p>
</header><main>
<h2>Design & Technology</h2>
<p>The constraint environment of computers heavily limits expresivenss in design. A bottom-up approach from the possibilities of technology removes that friction, but turns the act of design more into puzzle solving. Then knowing when to evolve the possibilities becomes the driver.</p>
<h3>Flow</h3>
<p><blockquote>Why would you make something difficult? The process can still be enjoyable and life already has an infinite challenge level.</blockquote></p>

<h2>Positional ergonomics</h2>
<p>Though controllers are different, they all share some minimum ergonomic shapes, this includes button positions. It is a common problem, when games have to tell you which button does what. The A button might be downwardly positioned or to the left, it might be green or blue, <a href="https://thoseawesomeguys.com/prompts/">it depends on the controller each platform makes.</a> Thinking about it in that way is an to shaky foundation. What remains more stable is the actual position of the buttons. When placing you hand on a controller your thums naturally rest upon 2 buttons. These are often the joystick and the other on a button. With these you can already control direction-strength and timing. The other buttons supplement these two and have to placed near.</p>
<figure>
	<img src="gamecube-controller.jpeg" alt="gamecube controller">
	<figcaption>The gamecube controllers button all have very different shapes and thus unique use cases to map towards an action.</figcaption>
</figure>
<h3>Action needs</h3>
<p>First comes the OK or forward button. This allows you to play. Then comes the CANCEL button, which allows for backward actions. Third is the OPTIONS button, giving more choice to the OK button. Last is the bind button, allowing for a custom shortcut without utilizing the menu.</p>
<figure>
	<img src="positional-buttons.gif" alt="positional-buttons">
	<figcaption>The buttons labeled with a color and symbol representing their action.</figcaption>
</figure>
<h2>Joypad</h2>
<img class="inverse"  src="PS5_Diagram_Simple.png" alt="PS5 Diagram Simple" loading="lazy">
<h3>Joystick</h3>
<p>Debuted with N64 with Super Mario 64 as it's showcase, the joystick allows for fine grained vector, direction and length, input.</p>


<h1> Easing Software Development</h1>
<p>The software development is one of the most uncooperative experiences, because a computer is the ultimate employee. It does exactly what it is told. However it can only understand exact instructions, so you have to tell it how to do it, to an degree that you could almost do it yourself already. Thus started the layering of abstractions, to control this one with a couple commands. In order to make it simpler I propose Extra-Ordinary Programming. This gives easy access and low maintainability cost, which naturally produces reuse. </p>

<h2>Functional Foldering</h2>
<p>How to organize your files? It is obvious that if you get too many files, that you need a folder to bundle files. This also allows to load files recursively on the needed context. But then there are many ways to organize the files into folders. The easiest way is by matching the file and folder together. This effectively creates an tree data structure with files as branching points. This constraints the freedom of file organizement in a constructive manner, allowing for inclusive expansion of files, making for a iterative file organizing process.</p>
<h3>Foldering Ergonomics</h3>
<p>When foldering the ergonomics are determined by the minimal changes of file-path length between navigation. Here file path follows a pattern of <code>base/page.extension</code>. This can be deepend by <code>base/page-folder/page.html</code> where page-folder can conveniently have the same name as the page.</p>
<h3>File Handlings</h3>
<p>In order to open files a handle is needed. Computers handles are not meaningful for humans thus we add a name to the handle.</p>
<h4>File extensions</h4>
<p>Every file is just stored as binary, thus file extensions don't matter for storing files. They specify how to open a file.</p>
<h4>File paths</h4>
<p>If your file paths are locally defined with functional foldering, then the filesystem will become self-organzing. You should expect filepaths like <code>page/file.extension</code> with a few shared exepetions.</p>
<h2>Evolving Software</h2>
<p>Over the years software has evolved from machine code too high-level languages and engines or editors. How can this progression be supported through individual codebases?</p>
<h3>Bottom-up development</h3>
<p>When desining software or computer games, you might know the pain of implementing such an idea. Software is still very limited in its freedom compared to human language, which is what we use to explain the original idea. A sensible approach then is to start from the software and find out what those systems can express. This makes it an explorative approach, which inherently makes it less plannable. Though software this approach suits software well, since it evolutionary and often iterative.</p>
<h3>Versioning</h3>
<p></p>

<h2>All data structures</h2>
<h2>Extra</h2>
<ul>
	<li><a href="<https://grugbrain.dev/#grug-on-chestertons-fence>">respecting the defaults.</a></li>
</ul>

<figure>
	<figcaption>Learning to code</figcaption>
	<img loading="lazy" src="golden-boy-fake-keyboard-programing-coding-paper-book.webp" alt="paper keyboard coding" loading="lazy">
</figure>
<h2>Gamepad Station</h2>
<p>Press any button on a connected gamepad to start!</p>
<!--
https://gamepad-tester.com/
https://xtrp.io/blog/2020/12/15/how-to-use-the-html5-gamepad-api/
https://www.voorhoede.nl/en/blog/navigating-the-web-with-a-gamepad/
Test vibration and joypad axes deadzones and curves.
https://luser.github.io/gamepadtest/
https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API/Using_the_Gamepad_API
<kbd></kbd>
-->
<p>‚ûïÔ∏èüè†Ô∏è‚ûñÔ∏è</p>

<table>
<tr>
<th>finger position</th>
<th></th>
</tr>
<tr><td>left thumb</td><td>axis</td><tr>
<tr><td>right point-finger</td><td>R1 button</td></tr>
<tr><td>right middle-finger</td><td>R2 axis</td></tr>
</table>
<button id="rumble">Rumble</button>
<button>soft heartbeat</button>
<script>
var gamepads = [];

window.addEventListener("gamepadconnected", (event) => {
	gamepads[event.gamepad.index] = (event.gamepad.id);
 
  console.log(gamepads);
});

window.addEventListener("gamepaddisconnected", (event) => {
	gamepads[event.gamepad.index] = null;
});

rumble.addEventListener("onclick", (event) => {
	gamepads[0].vibrationActuator.playEffect("dual-rumble", {
		startDelay: 0,
		duration: 1000,
		weakMagnitude: 1.0,
		strongMagnitude: 1.0
})});

</script>
<h2>Comparing input type</h2>
<p>Mouse: Quickest way
Keyboard: Flat 
Joypad: joy</p>
<h2>Comparing output</h2>
<p>All output is input is for the senses. This completes the sensorimotor contigency loop. Right now  this comprises visuals, sound and haptics.
</main><footer>¬© 2023 boukew99.</footer></body></html>
